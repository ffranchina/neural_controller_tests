import torch
import numpy as np

ROAD_LENGTH = 50
BUMPS = 3

from diffquantitative import DiffQuantitativeSemantic


class Car:
    """Describes the physical behaviour of the vehicle"""

    def __init__(self):
        self._max_acceleration = 5.0
        self._min_acceleration = -self._max_acceleration
        self._max_velocity = 10.0
        self._min_velocity = -self._max_velocity
        self.gravity = 9.81
        self.position = torch.tensor(0.0)
        self.velocity = torch.tensor(0.0)
        self.acceleration = torch.tensor(0.0)
        self.friction_coefficient = 0.01

    def update(self, in_acceleration, angle, dt):
        """Differential equation for updating the state of the car"""
        self.acceleration = torch.clamp(
            in_acceleration.reshape(1), self._min_acceleration, self._max_acceleration
        )
        self.acceleration -= self.gravity * torch.sin(angle)
        if self.velocity != 0:
            self.acceleration -= (
                self.friction_coefficient * self.gravity * torch.cos(angle)
            )
        self.velocity = torch.clamp(
            self.velocity + self.acceleration * dt,
            self._min_velocity,
            self._max_velocity,
        )
        self.position += self.velocity * dt


class Environment:
    def __init__(self):
        self._fn = lambda x: torch.tensor(0.0)
        self._max_angle = 25  # deg
        self._max_angular_coeff = np.tan(np.deg2rad(self._max_angle))
        self._dx = 0.1

    def set_agent(self, agent):
        self._agent = agent
        self.initialized()

    def initialized(self):
        self.actuators = 2 * BUMPS
        self.sensors = 0

    @property
    def status(self):
        """Representation of the state"""
        return ()

    def get_steepness(self, x):
        """Computes the value of the road's steepness in a given point"""
        x = torch.tensor(x) if not isinstance(x, torch.Tensor) else x
        dy = self._fn(x + self._dx) - self._fn(x)
        deriv = dy / torch.tensor(self._dx)
        return torch.clamp(deriv, -self._max_angular_coeff, self._max_angular_coeff)

    def get_fn(self, x):
        """Computes the value of the road's height in a given point"""
        derivative = np.array([self.get_steepness(i).numpy() for i in x])
        return np.cumsum(derivative) * self._dx

    def update(self, parameters, dt):
        """Generates the altimetric profile of the road"""
        if parameters is not None:
            parameters = parameters.reshape(2, BUMPS)

            def gaussian_rbf(x):
                x = x.reshape(1) if x.dim() == 0 else x
                w = parameters[0]
                sigma = parameters[1]
                mu = torch.tensor([20, 30, 40])

                phi = lambda x: torch.exp(-((x * sigma) ** 2))
                r = torch.abs(x[:, np.newaxis] - mu)

                return w.matmul(phi(r).t())

            self._fn = gaussian_rbf


class Agent:
    def __init__(self):
        self._car = Car()

    def set_environment(self, environment):
        self._environment = environment
        self.initialized()

    def initialized(self):
        self.actuators = 1
        self.sensors = len(self.status)

    @property
    def position(self):
        return self._car.position.clone()

    @position.setter
    def position(self, value):
        self._car.position = value

    @property
    def velocity(self):
        return self._car.velocity.clone()

    @velocity.setter
    def velocity(self, value):
        self._car.velocity = value

    @property
    def angle(self):
        return self._environment.get_steepness(self.position)

    @property
    def status(self):
        """Representation of the state"""
        return (self.velocity, self.angle)

    def update(self, parameters, dt):
        """Updates the physical state with the parameters
        generated by the NN.
        """
        acceleration = parameters
        self._car.update(acceleration, self.angle, dt)


class Model:
    """The model of the whole world.
    It includes both the attacker and the defender.
    """

    def __init__(self):
        self.agent = Agent()
        self.environment = Environment()

        self.agent.set_environment(self.environment)
        self.environment.set_agent(self.agent)

        self.traces = None

    def step(self, env_input, agent_input, dt):
        """Updates the physical world with the evolution of
        a single instant of time.
        """
        self.environment.update(env_input, dt)
        self.agent.update(agent_input, dt)

        self.traces["velo"].append(self.agent.velocity)

    @property
    def state(self):
        return (self.agent.position, self.agent.velocity)

    @state.setter
    def state(self, values):
        """Sets the world's state as specified"""
        agent_position, agent_velocity = values

        self.agent.position = torch.tensor(agent_position).reshape(1)
        self.agent.velocity = torch.tensor(agent_velocity).reshape(1)

    def reinitialize(self, agent_position, agent_velocity):
        """Sets the world's state as specified"""
        self.state = (agent_position, agent_velocity)

        self.traces = {"velo": []}


class RobustnessComputer:
    """Used to compute the robustness value (rho)"""

    def __init__(self, formula):
        self.dqs = DiffQuantitativeSemantic(formula)

    def compute(self, model):
        """Computes rho for the given trace"""
        v = model.traces["velo"]

        return self.dqs.compute(v=torch.cat(v))
