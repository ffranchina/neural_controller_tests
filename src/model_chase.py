import torch

import misc


class Drone:
    """Describes the physical behaviour of the drone"""

    def __init__(self):
        self._max_acceleration = 2.0
        self._min_acceleration = -self._max_acceleration
        self._max_velocity = 20.0
        self._min_velocity = -self._max_velocity
        self.position = torch.tensor((0.0, 0.0))
        self.velocity = torch.tensor((0.0, 0.0))
        self.acceleration = torch.tensor((0.0, 0.0))

    def update(self, in_acceleration, dt):
        """Differential equation for updating the state of the drone"""
        with torch.no_grad():
            norm = torch.linalg.norm(in_acceleration)

        if norm < self._max_acceleration and norm > self._min_acceleration:
            self.acceleration = in_acceleration
        else:
            self.acceleration = in_acceleration * self._max_acceleration / norm

        self.velocity = torch.clamp(
            self.velocity + self.acceleration * dt,
            self._min_velocity,
            self._max_velocity,
        )
        self.position += self.velocity * dt


class Environment:
    actuators = 1 * 2
    sensors = 3 * 2

    def __init__(self, label, nn, target_formula=None):
        self._label = label
        self._nn = nn

        self._robustness_computer = (
            misc.RobustnessComputer(target_formula) if target_formula else None
        )

        self._leader_drone = Drone()

    @property
    def label(self):
        return self._label

    @property
    def nn(self):
        return self._nn

    @property
    def robustness_computer(self):
        return self._robustness_computer

    def set_agent(self, agent):
        self._agent = agent

    @property
    def l_position(self):
        return self._leader_drone.position.clone()

    @l_position.setter
    def l_position(self, value):
        self._leader_drone.position = value

    @property
    def l_velocity(self):
        return self._leader_drone.velocity.clone()

    @l_velocity.setter
    def l_velocity(self, value):
        self._leader_drone.velocity = value

    @property
    def status(self):
        """Representation of the state"""
        return torch.flatten(
            torch.cat((self.l_velocity, self._agent.velocity, self._agent.distance))
        )

    def update(self, parameters, dt):
        """Updates the physical state with the parameters
        generated by the NN.
        """
        acceleration = parameters
        self._leader_drone.update(acceleration, dt)


class Agent:
    actuators = 1 * 2
    sensors = 3 * 2

    def __init__(self, label, nn, target_formula=None):
        self._label = label
        self._nn = nn

        self._robustness_computer = (
            misc.RobustnessComputer(target_formula) if target_formula else None
        )

        self._drone = Drone()

    @property
    def label(self):
        return self._label

    @property
    def nn(self):
        return self._nn

    @property
    def robustness_computer(self):
        return self._robustness_computer

    def set_environment(self, environment):
        self._environment = environment

    @property
    def position(self):
        return self._drone.position.clone()

    @position.setter
    def position(self, value):
        self._drone.position = value

    @property
    def velocity(self):
        return self._drone.velocity.clone()

    @velocity.setter
    def velocity(self, value):
        self._drone.velocity = value

    @property
    def distance(self):
        return self._environment.l_position - self._drone.position

    @property
    def status(self):
        """Representation of the state"""
        return torch.flatten(
            torch.cat((self._environment.l_velocity, self.velocity, self.distance))
        )

    def update(self, parameters, dt):
        """Updates the physical state with the parameters
        generated by the NN.
        """
        acceleration = parameters
        self._drone.update(acceleration, dt)


class Model:
    """The model of the whole world.
    It includes both the attacker and the defender.
    """

    def __init__(self, environment, *agents):
        self.agent = agents[0]
        self.environment = environment

        self.agent.set_environment(self.environment)
        self.environment.set_agent(self.agent)

    def step(self, env_input, agent_input, dt):
        """Updates the physical world with the evolution of
        a single instant of time.
        """
        self.environment.update(env_input, dt)
        self.agent.update(agent_input, dt)

    @property
    def state(self):
        return (
            self.agent.position,
            self.agent.velocity,
            self.environment.l_position,
            self.environment.l_velocity,
        )

    @state.setter
    def state(self, values):
        """Sets the world's state as specified"""
        agent_position, agent_velocity, leader_position, leader_velocity = values

        self.agent.position = torch.tensor(agent_position).reshape(2)
        self.agent.velocity = torch.tensor(agent_velocity).reshape(2)
        self.environment.l_position = torch.tensor(leader_position).reshape(2)
        self.environment.l_velocity = torch.tensor(leader_velocity).reshape(2)

    @property
    def observables(self):
        return {"dist": torch.linalg.norm(self.agent.distance).reshape(1)}

    def reinitialize(
        self, agent_position, agent_velocity, leader_position, leader_velocity
    ):
        """Sets the world's state as specified"""
        self.state = (agent_position, agent_velocity, leader_position, leader_velocity)
