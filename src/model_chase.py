import torch

import misc


class Drone:
    """Describes the physical behaviour of the drone"""

    def __init__(self):
        self._max_acceleration = 2.0
        self._min_acceleration = -self._max_acceleration
        self._max_velocity = 20.0
        self._min_velocity = -self._max_velocity
        self.position = torch.tensor((0.0, 0.0))
        self.velocity = torch.tensor((0.0, 0.0))
        self.acceleration = torch.tensor((0.0, 0.0))

    def update(self, in_acceleration, dt):
        """Differential equation for updating the state of the drone"""
        with torch.no_grad():
            norm = torch.linalg.norm(in_acceleration)

        if norm < self._max_acceleration and norm > self._min_acceleration:
            self.acceleration = in_acceleration
        else:
            self.acceleration = in_acceleration * self._max_acceleration / norm

        self.velocity = torch.clamp(
            self.velocity + self.acceleration * dt,
            self._min_velocity,
            self._max_velocity,
        )
        self.position += self.velocity * dt


class Environment:
    def set_agents(self, agents):
        self._agents = agents

    @property
    def leader(self):
        return self._agents["leader"]

    @property
    def follower(self):
        return self._agents["follower"]


class Agent:
    actuators = 1 * 2
    sensors = 3 * 2

    def __init__(self, label, nn, target_formula=None):
        self._label = label
        self._nn = nn

        self._robustness_computer = (
            misc.RobustnessComputer(target_formula) if target_formula else None
        )

        self._drone = Drone()

    @property
    def label(self):
        return self._label

    @property
    def nn(self):
        return self._nn

    @property
    def robustness_computer(self):
        return self._robustness_computer

    def set_environment(self, environment):
        self._environment = environment

    @property
    def position(self):
        return self._drone.position.clone()

    @position.setter
    def position(self, value):
        self._drone.position = value

    @property
    def velocity(self):
        return self._drone.velocity.clone()

    @velocity.setter
    def velocity(self, value):
        self._drone.velocity = value

    @property
    def distance(self):
        return self._environment.leader.position - self._environment.follower.position

    @property
    def status(self):
        """Representation of the state"""
        return torch.flatten(
            torch.cat(
                (
                    self._environment.leader.velocity,
                    self._environment.follower.velocity,
                    self.distance,
                )
            )
        )

    def update(self, parameters, dt):
        """Updates the physical state with the parameters
        generated by the NN.
        """
        acceleration = parameters
        self._drone.update(acceleration, dt)


class Model:
    """The model of the whole world.
    It includes both the attacker and the defender.
    """

    def __init__(self, environment, *agents):
        self.environment = environment
        self.agents = {agent.label: agent for agent in agents}

        self.environment.set_agents(self.agents)
        for agent in self.agents.values():
            agent.set_environment(self.environment)

    def step(self, agent_actions, dt):
        """Updates the physical world with the evolution of
        a single instant of time.
        """
        for label, agent in self.agents.items():
            agent.update(agent_actions[label], dt)

    @property
    def state(self):
        return (
            self.agents["follower"].position,
            self.agents["follower"].velocity,
            self.agents["leader"].position,
            self.agents["leader"].velocity,
        )

    @state.setter
    def state(self, values):
        """Sets the world's state as specified"""
        agent_position, agent_velocity, leader_position, leader_velocity = values

        self.agents["follower"].position = torch.tensor(agent_position).reshape(2)
        self.agents["follower"].velocity = torch.tensor(agent_velocity).reshape(2)
        self.agents["leader"].position = torch.tensor(leader_position).reshape(2)
        self.agents["leader"].velocity = torch.tensor(leader_velocity).reshape(2)

    @property
    def observables(self):
        return {"dist": torch.linalg.norm(self.agents["follower"].distance).reshape(1)}

    def reinitialize(
        self, agent_position, agent_velocity, leader_position, leader_velocity
    ):
        """Sets the world's state as specified"""
        self.state = (agent_position, agent_velocity, leader_position, leader_velocity)
